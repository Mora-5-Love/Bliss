
Subject:
Re: new hope for bliss
From:
Tancrede Lepoint <tancrede.lepoint@sri.com>
Date:
9/12/16, 7:00 PM
To:
"iam@csl.sri.com" <iam@csl.sri.com>
CC:
"bruno@csl.sri.com" <bruno@csl.sri.com>

Hi Ian, hi Bruno,

I am sorry I didn’t write back earlier about that, these past two weeks 
have been rather busy. Enjoy your offline solitude :)

As I told you, the main thing I would like to do by the end of the year 
is to incorporate BLISS into OpenSSL, more precisely a modified variant 
of BLISS-B in OpenSSL.

BLISS has a website (http://bliss.di.ens.fr) where you can find:
- [DDLL13] the initial paper, http://eprint.iacr.org/2013/383
- [Duc13] the BLISS-B variant, http://eprint.iacr.org/2014/874
- a dirty proof-of-concept implementation, which doesn’t work anymore with current NTL versions,
- [SS] a link to strongSwan which includes BLISS-B https://wiki.strongswan.org/projects/strongswan/wiki/BLISS
- an FPGA implementation

I would like also to mention 
[NEWHOPE] https://eprint.iacr.org/2015/1092.pdf, a lattice-based 
key exchange that is incorporated into Google certificates in Google
Chrome.

BLISS and New Hope are based on ring lattices; more precisely, we 
are working over polynomials ZZ[x] / (x^512+1) and ZZ[x] / (x^1024+1) 
with coefficients modulo q = 12289. Polynomials are often represented
as arrays of uintXX_t (where XX can be chosen to be 16, 32, or 64) and 
multiplication is performed using the NTT (Number Theoretic Transform).
They both use Gaussian sampling, but in New Hope it does not need a lot 
of precision, so it can be easily implemented. BLISS is more tricky on this
aspect and need a Gaussian sampling of better quality.

I only have about 100h from Pat to dedicate to your parts of the implementation,
so please don’t overcharge the charge code I gave you. As I told you, some bits 
already exist as part of the New Hope implementation, and can serve as basis.

What I would be interested in:


# Portable implementation of Gaussian sampling algorithm(s) in C

You can find here https://www.math.auckland.ac.nz/~sgal018/gen-gaussians.pdf 
a good introduction to Gaussian sampling, to be followed by [DDLL13, Sec. 6].

I would be interested by a portable implementation of one or several Gaussian
sampling algorithms for standard deviation ~ 100, or ~200. If the algorithm 
that is implemented is [DDLL13, Sec. 6], I only need more than 40 bits of 
precision for the Bernoulli’s (in other words, you can use a 64bits register).

I don’t necessarily need the implementation of [DDLL13], it could be one of the
others as long as the final code is readable and fast. When using tables, it would 
be good to be protected against cache attacks - https://eprint.iacr.org/2016/300.pdf.


# Portable fast and efficient implementation of the NTT (and inverse-NTT) in C

Several implementations already exist for the NTT. I would be interested in an
implementation that is faster than the [NEWHOPE] implementation (but if it is 
too difficult, I will use that one). Some interesting directions could be:
- Harvey’s NTT https://arxiv.org/pdf/1205.2926.pdf
- a NTT in C++ in NFLlib https://github.com/quarkslab/NFLlib that I co-developed 
that could end-up being faster than Harvey’s NTT (see NFLlib/tests/ntt_perfs.cpp)
and use the fact that q = 12289 is only 14-bit long (which means that the top two 
most significant bits in a 16-bit register can be used to speed up the computation).
- a recent paper of Microsoft on this subject (https://eprint.iacr.org/2016/504.pdf)
and the related implementation.

Several things to keep in mind (please also read the papers and the section 
on it in [NEWHOPE]): 
* we are working with a NTT where the coefficients also have to be multiplied by 
powers of a primitive root of x^n+1. The choice of the root doesn’t matter to me. 
* it should be constant-time (i.e. the running should not depend on the values of 
the input) 


# Portable and fast and secure SHAKE-128 (in C)

See [NEWHOPE] for references. Shake-128 is based on SHA-3, recently standardized 
by NIST.


# An efficient implementation in C that inverts in the ring  ZZ[x] mod (x^n+1, q)

I will have to invert polynomials in the ring: is it possible to do it efficiently? Do
we have to use an extended Bezout algorithm in the ring? What can be done here?



Please let me know if you have questions, and what you would be interested in working on.

Thank you very much.
-Tancrède.






> On Sep 9, 2016, at 11:31 AM, Ian A Mason <iam@csl.sri.com> wrote:
>
>
> Hi Tancrede,
>
>
> Just touching base. I am about to go offline for 2 weeks solitude
>
> in the south west.  Maybe when I get back there will be time for us
>
> to discuss your project?
>
>
>
> Cheers, Ian.
>

